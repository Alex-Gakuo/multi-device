{{+bindTo:partials.standard_multidevice_article}}

<style>
dd { margin: 0 6px 12px 40px; }
</style>

<h1>Chrome Custom Tabs</h1>

<h2>What are Chrome Custom Tabs?</h2>
<p>App developers face a choice when a user clicks a URL to either launch a
browser, or build their own in-app browser using webviews.</p>

<p>Both options present challenges &mdash; launching the browser is a heavy context
switch that isn't customizable, while webviews don't share state with the
browser and add overhead to maintain.</p>

<p>Chrome Custom Tabs give apps more control over their web experience, and making
transitions between native and web content more seamless without having to
resort to a webview.</p>

<p>Chrome Custom Tabs allow an app to customize how Chrome looks and feels. An app
can change things like:</p>

<ul>
	<li>Toolbar color</li>
	<li>Enter and exit animations</li>
	<li>Add custom actions to the Chrome toolbar and overflow menu</li>
</ul>

<p>Chrome Custom Tabs also allow the developer to pre-start Chrome and pre-fetch
content for faster loading.</p>

<p>
	You can test this now with our <a href="https://github.com/GoogleChrome/hosted-chrome-client">Chrome custom tab sample</a> on Github. 
</p>

<h2>When should I use Chrome Custom Tabs vs WebView?</h2>

<p>The WebView is good solution if you are hosting your own content inside your
app.  If your app directs people to URLs outside your domain  we recommend
that you use Chrome Custom Tabs because:</p>

<ul>
	<li>Simple to implement.  No need to build code to manage requests, permission
	grants or cookie stores.</li>
	<li>UI customization:
		<ul>
		<li>Toolbar color</li>
		<li>Action button</li>
		<li>Custom menu items</li>
		<li>Custom in/out animations</li>
		</ul>
	</li>
	<li>Navigation awareness: the browser delivers a callback to the application upon
an external navigation.</li>
	<li>Performance optimization:
	<ul>
	<li>Pre-warming of the Browser in the background, while avoiding stealing
	resources from the application</li>
	<li>Providing a likely URL in advance to the browser, which may perform
	speculative work, speeding up page load time.</li>
	</ul></li>
	<li>Lifecycle management: the browser prevents the application from being evicted
	by the system while on top of it, by raising its importance to the
	"foreground" level.</li>
	</ul>
	<li>Shared Cookie Jar and permissions model so users don't have to log in to sites
	they are already connected to, or re-grant permissions they have already
	granted.</li>
	<li>If the user has turned on Data Saver they will still benefit from it</li>
	<li>Synchronised AutoComplete across devices for better form completion</li>
	<li>Simple customization model</li>
	<li>Quickly return to app with a single click</li>
	<li>You want to use the latest browser implementations on devices pre-Lollipop
	(Auto updating webview) instead of older WebViews</li>
</ul>

<h2>When will this be available?</h2>

<p>As of Chome 44, Chrome Custom Tabs are available in 
	<a href="https://play.google.com/store/apps/details?id=com.chrome.dev&hl=en">Chrome Dev Channel</a> on
all of Chrome's support Android versions (Jellybean onwards) and the API will
change slightly over the coming weeks.</p>

<p>We are looking for feedback, questions and suggestions on this project so we
encourage you to file issues on <a href="https://crbug.com">crbug.com</a> and ask questions in our forum
Chromium Dev.</p>

<h2>Implementation Guide</h2>

<p>If you follow the guidance from this page you will be able to create a great
integration.</p>

<pre>
/*
  Note: The extra hosted mode will change to the following in the near future.
  private static final String EXTRA_HOSTED_MODE = "com.android.chrome.hosted_mode";
*/

private static final String EXTRA_HOSTED_MODE = "com.android.chrome.append_task";
String url = ¨https://paul.kinlan.me/¨;
Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
intent.putExtra(EXTRA_HOSTED_MODE, true);</pre>

<h2>What happens if the user doesn’t have a recent version of Chrome installed?</h2>

<p>We are using the ACTION_VIEW Intent, this means that by default the page will
open in the system browser, or the user's default browser.</p>

<p>If the user has Chrome installed and it is the default browser, it will
automatically pick up the EXTRAS and present a customized UI.  It is also
possible for another browser to use the intent extras to provide a similar
customized interface.</p>

<h2>How can I check whether Chrome supports Custom Tabs?</h2>

All versions of Chrome supporting Custom Tabs expose a service
 (see the later section “Connect to the Service”). To check whether Chrome supports 
 Custom Tabs, try to bind to the service. If it succeeds, then 
 Custom Tabs can safely be used. 

<h2>Configure the color of the address bar</h2>

<p>One of the most important (and simplest to implement) aspects of Chrome Custom
Tabs is the ability for you to change the colour of the address bar to be
consistent with your theme.
</p>

<pre>
// Extra that changes the background color for the omnibox. colorRes is an int
// that specifies a
<a href="http://developer.android.com/reference/android/graphics/Color.html">Color</a>.

private static final String EXTRA_HOSTED_TOOLBAR_COLOR = "hosted:toolbar_color";
intent.putExtra(EXTRA_HOSTED_TOOLBAR_COLOR, colorRes);
</pre>

<h2>Configure custom Enter and exit animations</h2>

<p>Many Android applications use custom View Entrance and Exit animations when
transition between Activities on Android.  Chrome Custom Tabs is no different,
you can change the entrance and exit (when the user presses Back) animations to
keep them consistent with the rest of your application.</p>

<pre>// Bundle constructed out of
<a href="http://developer.android.com/reference/android/app/ActivityOptions.html#makeCustomAnimation(android.content.Context,%20int,%20int)">ActivityOptions</a>
that Chrome will be running when
// it finishes HostedActivity. A similar ActivityOptions for starting
// Chrome should be constructed and given to the
<a href="http://developer.android.com/reference/android/app/Activity.html#startActivity(android.content.Intent,%20android.os.Bundle)">startActivity</a>()
call that
// launches Chrome.
private static final String EXTRA_HOSTED_EXIT_ANIMATION_BUNDLE = "hosted:exit_animation_bundle";

Bundle finishBundle = ActivityOptions.makeCustomAnimation(context, R.anim.clientEnterAnimResId, R.anim.ChromeExitAnimResId).toBundle;
intent.putExtra(EXTRA_HOSTED_EXIT_ANIMATION_BUNDLE, finishBundle);
Bundle startBundle = ActivityOptions.makeCustomAnimation(context, R.anim.ChromeEnterAnimResId, R.anim.clientExitAnimResId).toBundle;

startActivity(intent, startBundle);</pre>


<h2>Configure a custom action button</h2>

<img src="/multidevice/images/customtab/action.jpg" style="float: left; max-width: 300px;">

<p>As the developer of your app you have full control over the Action Button that
is presented to your users inside the Chrome tab.</p>

<p>In most cases this will be a primary action such as Share, or another common
activity that your users will perform.</p>

<p>The Action Button is represented as a Bundle with an icon of the action button
and a pendingIntent that will be called by Chrome when your user hits the action
button.</p>

<pre>// Key that specifies the
<a href="http://developer.android.com/reference/android/graphics/Bitmap.html">Bitmap</a> to
be used as the <a href="http://developer.android.com/reference/android/widget/ImageView.html#setImageDrawable(android.graphics.drawable.Drawable)">image
source</a> for the
// action button.

private static final String KEY_HOSTED_ICON = "hosted:icon";
<p>// Key that specifies the PendingIntent to launch when the action button
// or menu item was clicked. Chrome will be calling
<a href="http://developer.android.com/reference/android/app/PendingIntent.html#send(android.content.Context,%20int,%20android.content.Intent)">PendingIntent#send()</a> on
// clicks after adding the url as data. The client app can call
//
<a href="http://developer.android.com/reference/android/content/Intent.html#getDataString()">Intent#getDataString()</a>
to get the url.
private static final String KEY_HOSTED_PENDING_INTENT = "hosted:pending_intent";
// Use a bundle for the action button parameters.
private static final String EXTRA_HOSTED_ACTION_BUTTON_BUNDLE = "hosted:action_button_bundle"

Bundle actionButtonBundle = new Bundle();
actionButtonBundle.putParcelable(KEY_HOSTED_ICON, icon);
actionButtonBundle.putParcelable(KEY_HOSTED_PENDING_INTENT, pendingIntent);

// Associate the action button bundle with the VIEW Intent
intent.putExtra(EXTRA_HOSTED_ACTION_BUTTON_BUNDLE, actionButtonBundle);</pre>

<p>Configure a custom menu</p>

<img src="/multidevice/images/customtab/menu.jpg" style="float: left; max-width: 300px;"">
<p>The Chrome browser has a comprehensive menu of actions that users will perform
frequently inside a browser, however they may not be relevant to your
application context.</p>

<p>Chrome Custom tabs will have a three icon row with &quot;Forward&quot;,&quot;Page Info&quot; and
&quot;Refresh&quot; on top at all times, with &quot;Find in Page&quot; and &quot;Open in Browser&quot; on the
footer of the menu.</p>

<p>As the developer you can add and customized up to menu items that will appear
between the icon row and foot items.</p>

<p>The menu is represented as an Array of Bundles (currently without an icon), menu
text and a pendingIntent that Chrome will call on your behalf when the user taps
the item.</p>

<pre>// Key for the title string for a given custom menu item
private static final String KEY_HOSTED_MENU_TITLE = "hosted:menu_title";
// Use an ArrayList&lt;Bundle&gt; for specifying menu related params. There
should be
//a separate Bundle for each custom menu item.
private static final String EXTRA_HOSTED_MENU_ITEMS = "hosted:menu_items";
ArrayList&lt;Bundle&gt; menuItemBundleList = new ArrayList&lt;&gt;();

// For each menu item do:
Bundle menuItem = new Bundle();
menuItem.putString(KEY_HOSTED_TITLE, menuItemTitle);
menuItem.putParcelable(KEY_HOSTED_PENDING_INTENT, pendingIntent);
menuItemBundleList.add(menuItem);
intent.putParcelableArrayList(EXTRA_HOSTED_MENU_ITEMS, menuItemBundleList);</pre>


<h2>Warm up Chrome to make pages load instantly</h2>

<p>By default when startActivity is called with the correctly configured
ACTION_VIEW intent it will spin up Chrome and launch the URL. This can take up
precious time and impact on the perception of smoothness.</p>

<p>We believe that users demand a near instantaneous experience and we have
provided a Service in Chrome that your App can connect to and tell Chrome to
warm up the browser and the native components.  We are also experimenting with
the ability for you, the developer to tell Chrome the likely set of web pages
the user will visit.  Chrome will then be able to:</p>

<ul>
	<li>DNS pre-resolution of the main domain</li>
	<li>DNS resolution of the most likely sub-resources</li>
	<li>Pre-connection to the destination including HTTPS/TLS negotiation.</li>
	</ul>
	<p>The process for warming up Chrome is as follows:</p>
	<ul>
	<li>Connect to the service</li>
	<li>Attach a navigation callback with `finishCallback` so that you know a page
	was loaded.</li>
	<li>On the service call `warmup` to start Chrome behind the scenes</li>
	<li>Create a `newSession`, this session is used for all requests to the API</li>
	<li>Tell Chrome which pages the user is likely to load with `mayLaunchUrl`</li>
	<li>Launch the VIEW intent as per normal.</li>
</ul>

<h2>Connect to the Service</h2>

<p>If you are not familiar with Connecting to Android the interface is created with
<a href="http://developer.android.com/guide/components/aidl.html">AIDL</a> and
automatically creates a proxy service class for you.</p>
	
<pre>
// Package name for the Chrome channel, the client wants to connect to. This
// depends on the channel name.
// Stable = com.android.chrome
// Beta = com.chrome.beta
// Dev = com.chrome.dev
private static final String CHROME_PACKAGE_NAME;
private static final String SERVICE_CLASS_NAME = "org.chromium.chrome.browser.hosted.ChromeConnectionService";
Intent serviceIntent = new Intent();
serviceIntent.setClassName(CHROME_PACKAGE_NAME, SERVICE_CLASS_NAME);
context.bindService(serviceIntent, mServiceConnection, flags);
</pre>

<h2>Attach Navigation Callback</h2>

<p>long finishSetup(IBrowserConnectionCallback callback)</p>
<p>Set the callback triggered on an external navigation. This method must be called
right after the service connection, and must be called again if the service gets
disconnected. Only one call to this method is allowed, following ones will
return an error.</p>
<p>If you are plan to warm up Chrome this must also be called before the VIEW
intent is sent to the browser, otherwise it won't be possible to link the tab
created to the provided callback and you will not recieve notifications of
navigation.</p>
<p>Returns 0 for success.</p>

<h2>Warm up the Browser Process</h2>

<p>long warmup(long flags)</p>
<p>Warm up the browser process and loads the native libraries so that the Chome
Custom Tabl lauches instantly.  The Warmup process is asynchronous, the return
value indicates that the request has been accepted.</p>
<p>Returns 0 for success.</p>

<h2>Create a new tab session</h2>

<p>long newSession()</p>
<p>Session ID is used in subsequent calls to link mayLaunchUrl call, the VIEW
intent and the tab generated to each other. Using this ID, it is possible to
send mayLunchUrl calls and intents to an already created tab as well.</p>
<p>Returns the sessionID. A negative number to signal an error, or a positive new
session ID.</p>

<h2>Tell Chrome what URL's the user is likely to open</h2>
<p>long mayLaunchUrl(long sessionId, String url, Bundle extras, List&lt;Bundle&gt;
otherLikelyBundles)</p>
<p>Indicate to the browser of a likely future navigation to a URL so that it can
pre-cache and prepare the connection and the page before it is shown to the
user. The most likely URL must be specified first. Optionally, a list of other
likely URLs can be provided. They are treated as less likely than the first one,
and have to be sorted in decreasing priority order. These additional URLs may be
ignored.</p>
<p><strong>Note</strong>: The method warmup() has to be called first. Each bundle inside
otherLikelyBundles has to provide a url string value. All previous calls to this
method will be deprioritized.</p>
<p>Returns the sessionId if it is known by the service, a number &lt; 0 to signal
an error.</p>

<h2>FAQ</h2>
<ul>
<li>Is this available on iOS
<ul>
<li>No. There is a project that allows you to integrate Chrome into your app
in a similar but completely separate way.</li>
</ul>
</li>
<li>When will this be available in Stable?
<ul>
<li>We don't have a fixed date or version of Chrome yet. The normal release
cycle from being in the Dev Channel of Chrome is about 12 weeks, however
we are looking for feedback from developers first.</li>
</ul>
</li>
<li>Where can I ask questions
<ul>
<li>Chromium-discuss</li>
<li>Stackoverflow tag: Chrome Custom Tabs</li>
</ul>
</li>
</ul>


{{/partials.standard_multidevice_article}}
